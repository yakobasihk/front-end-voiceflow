import { BaseCommand, Nullable, SlotMapping } from '@voiceflow/api-sdk';
import { AnyRequestButton } from "../request";
import { AnyButton, ButtonsLayout, Chip, ExpressionType, ExpressionTypeV2, Prompt } from "../types";
export { BaseCommand, BaseNode, BasePort, BaseStep } from '@voiceflow/api-sdk';
export interface StepDataWithReprompt<V> {
    reprompt: Nullable<Prompt<V>>;
}
export interface NodeWithReprompt {
    reprompt?: string;
}
export interface StepDataWithButtons {
    buttons?: Nullable<AnyButton[]>;
    buttonsLayout?: Nullable<ButtonsLayout>;
    /**
     * @deprecated Use buttons
     */
    chips: Nullable<Chip[]>;
}
export interface NodeWithButtons {
    buttons?: AnyRequestButton[];
    /**
     * @deprecated Use buttons
     */
    chips?: Chip[];
}
export interface DataWithMappings {
    mappings?: SlotMapping[];
}
export declare enum TraceType {
    END = "end",
    PATH = "path",
    FLOW = "flow",
    SPEAK = "speak",
    BLOCK = "block",
    DEBUG = "debug",
    CHOICE = "choice",
    STREAM = "stream",
    VISUAL = "visual"
}
export declare type NodeID = Nullable<string>;
export declare enum NodeType {
    SPEAK = "speak",
    START = "start",
    CARD = "card",
    INTERACTION = "interaction",
    SET = "set",
    SET_V2 = "setV2",
    IF = "if",
    IF_V2 = "ifV2",
    RANDOM = "random",
    CAPTURE = "capture",
    API = "api",
    ZAPIER = "zapier",
    INTEGRATIONS = "integrations",
    GOOGLE_SHEETS = "google_sheets",
    INTENT = "intent",
    FLOW = "flow",
    CODE = "code",
    EXIT = "exit",
    PROMPT = "prompt",
    COMMAND = "command",
    TRACE = "trace",
    STREAM = "stream",
    VISUAL = "visual",
    GENERAL = "general",
    DIRECTIVE = "directive",
    DEPRECATED = "deprecated"
}
export declare enum IntegrationType {
    ZAPIER = "Zapier",
    CUSTOM_API = "Custom API",
    GOOGLE_SHEETS = "Google Sheets"
}
export declare enum IntegrationPlatform {
    ZAPIER = "Zapier",
    GOOGLE_SHEETS = "Google Sheets"
}
export interface IntegrationUser {
    user_id?: string;
    platform?: IntegrationPlatform;
    user_data?: {
        email?: string;
        name?: string;
    };
    created_at?: string;
    creator_id?: number;
    project_id?: Nullable<string>;
    requires_refresh?: Nullable<boolean>;
    integration_user_id?: string;
}
export interface GenericExpression<T extends ExpressionType, V> {
    type: T;
    value: V;
    depth: number;
}
export declare type ExpressionTuple = [Expression, Expression];
export interface NotExpression {
    type: ExpressionType.NOT;
    value: Expression;
    depth: number;
}
export declare type OrExpression = GenericExpression<ExpressionType.OR, ExpressionTuple>;
export declare type AndExpression = GenericExpression<ExpressionType.AND, ExpressionTuple>;
export declare type LessExpression = GenericExpression<ExpressionType.LESS, ExpressionTuple>;
export declare type PlusExpression = GenericExpression<ExpressionType.PLUS, ExpressionTuple>;
export declare type MinusExpression = GenericExpression<ExpressionType.MINUS, ExpressionTuple>;
export declare type TimesExpression = GenericExpression<ExpressionType.TIMES, ExpressionTuple>;
export declare type ValueExpression = GenericExpression<ExpressionType.VALUE, string>;
export declare type DivideExpression = GenericExpression<ExpressionType.DIVIDE, ExpressionTuple>;
export declare type EqualsExpression = GenericExpression<ExpressionType.EQUALS, ExpressionTuple>;
export declare type GreaterExpression = GenericExpression<ExpressionType.GREATER, ExpressionTuple>;
export declare type AdvancedExpression = GenericExpression<ExpressionType.ADVANCE, string>;
export declare type VariableExpression = GenericExpression<ExpressionType.VARIABLE, string>;
export declare type Expression = OrExpression | AndExpression | NotExpression | LessExpression | PlusExpression | MinusExpression | TimesExpression | ValueExpression | DivideExpression | EqualsExpression | GreaterExpression | AdvancedExpression | VariableExpression;
export declare enum ConditionsLogicInterface {
    VARIABLE = "variable",
    VALUE = "value",
    LOGIC_GROUP = "logic_group",
    EXPRESSION = "expression"
}
export interface GenericExpressionV2<T extends ExpressionTypeV2, V> {
    type: Nullable<T>;
    value: V;
    name?: string;
    logicInterface?: ConditionsLogicInterface;
}
export declare type ExpressionTupleV2 = [ExpressionV2?, ExpressionV2?];
export declare type ValueExpressionV2 = GenericExpressionV2<ExpressionTypeV2.VALUE, string>;
export declare type AdvancedExpressionV2 = GenericExpressionV2<ExpressionTypeV2.ADVANCE, string>;
export declare type VariableExpressionV2 = GenericExpressionV2<ExpressionTypeV2.VARIABLE, string>;
export declare type OrExpressionV2 = GenericExpressionV2<ExpressionTypeV2.OR, ExpressionTupleV2>;
export declare type AndExpressionV2 = GenericExpressionV2<ExpressionTypeV2.AND, ExpressionTupleV2>;
export declare type LessExpressionV2 = GenericExpressionV2<ExpressionTypeV2.LESS, ExpressionTupleV2>;
export declare type EqualsExpressionV2 = GenericExpressionV2<ExpressionTypeV2.EQUALS, ExpressionTupleV2>;
export declare type GreaterExpressionV2 = GenericExpressionV2<ExpressionTypeV2.GREATER, ExpressionTupleV2>;
export declare type IsEmptyExpression = GenericExpressionV2<ExpressionTypeV2.IS_EMPTY, ExpressionTupleV2>;
export declare type ContainsExpression = GenericExpressionV2<ExpressionTypeV2.CONTAINS, ExpressionTupleV2>;
export declare type NotEqualExpression = GenericExpressionV2<ExpressionTypeV2.NOT_EQUAL, ExpressionTupleV2>;
export declare type EndsWithExpression = GenericExpressionV2<ExpressionTypeV2.ENDS_WITH, ExpressionTupleV2>;
export declare type HasValueExpression = GenericExpressionV2<ExpressionTypeV2.HAS_VALUE, ExpressionTupleV2>;
export declare type NotContainExpression = GenericExpressionV2<ExpressionTypeV2.NOT_CONTAIN, ExpressionTupleV2>;
export declare type StartsWithExpression = GenericExpressionV2<ExpressionTypeV2.STARTS_WITH, ExpressionTupleV2>;
export declare type LessOrEqualExpression = GenericExpressionV2<ExpressionTypeV2.LESS_OR_EQUAL, ExpressionTupleV2>;
export declare type GreaterOrEqualExpression = GenericExpressionV2<ExpressionTypeV2.GREATER_OR_EQUAL, ExpressionTupleV2>;
export declare type ExpressionV2 = OrExpressionV2 | AndExpressionV2 | LessExpressionV2 | ValueExpressionV2 | EqualsExpressionV2 | GreaterExpressionV2 | VariableExpressionV2 | AdvancedExpressionV2 | IsEmptyExpression | NotEqualExpression | ContainsExpression | EndsWithExpression | HasValueExpression | NotContainExpression | StartsWithExpression | LessOrEqualExpression | GreaterOrEqualExpression;
export declare type LogicGroupData = GenericExpressionV2<ExpressionTypeV2.AND | ExpressionTypeV2.OR, ExpressionV2[]>;
export declare type ExpressionData = GenericExpressionV2<ExpressionTypeV2.AND | ExpressionTypeV2.OR, (ExpressionV2 | LogicGroupData)[]>;
export declare enum EventType {
    INTENT = "intent"
}
export interface BaseEvent {
    type: string;
}
/**
 * @deprecated
 */
export declare type Event<T extends string = string, D = unknown> = {
    type: T;
} & D;
export interface IntentEvent extends BaseEvent, DataWithMappings {
    type: EventType;
    intent: string;
}
export declare enum CommandType {
    JUMP = "jump",
    PUSH = "push"
}
export interface TypedBaseCommand<E extends BaseEvent = BaseEvent> extends BaseCommand {
    type: CommandType;
    event: E;
}
export interface JumpCommand<E extends BaseEvent = BaseEvent> extends TypedBaseCommand<E> {
    type: CommandType.JUMP;
    nextID: Nullable<string>;
}
export interface PushCommand<E extends BaseEvent = BaseEvent> extends TypedBaseCommand<E> {
    type: CommandType.PUSH;
    diagramID: Nullable<string>;
}
export declare type Command<E extends BaseEvent = BaseEvent> = JumpCommand<E> | PushCommand<E>;
export interface BaseTraceFramePath<E extends BaseEvent = BaseEvent> {
    event: E;
}
export interface BaseTraceFrame<P = any, E extends BaseEvent = BaseEvent> {
    type: string;
    paths?: BaseTraceFramePath<E>[];
    payload: P;
    defaultPath?: number;
}
